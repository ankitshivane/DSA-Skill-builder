
# üìò Time Complexity Learning Roadmap (Index)

### **Part 1 ‚Äì Foundations**

1. **Why Time Complexity?**

    * What is it? Why not just measure in seconds?
    * Real-world analogy.

2. **Mathematical Basics Refresher** (don‚Äôt worry, I‚Äôll explain simply):

    * Functions & growth rates.
    * Logarithms (what they mean).
    * Exponents & powers.
    * Summations & series (only the simple useful ones).

3. **Introduction to Big-O Notation**

    * What Big-O actually means.
    * Rules for simplifying (dropping constants, lower-order terms).
    * Common complexity classes.

---

### **Part 2 ‚Äì Common Complexities**

4. **Constant Time ‚Äì O(1)**

    * Examples from real life & code.

5. **Logarithmic Time ‚Äì O(log n)**

    * Intuition: halving problems.
    * Binary search explained step by step.

6. **Linear Time ‚Äì O(n)**

    * Scanning/iterating problems.

7. **Linearithmic Time ‚Äì O(n log n)**

    * Sorting (Merge Sort/Quick Sort basics).

8. **Quadratic & Higher ‚Äì O(n¬≤), O(n¬≥), ‚Ä¶**

    * Nested loops explained.

9. **Exponential & Factorial ‚Äì O(2‚Åø), O(n!)**

    * Why they are terrible in practice.
    * Relation to brute force problems.

---

### **Part 3 ‚Äì Mastering Analysis**

10. **Best, Worst, and Average Cases**

    * Why not always worst case?

11. **Space Complexity**

    * Memory analysis, stack vs heap.

12. **Comparing Algorithms**

    * Graphing complexities.
    * Tradeoffs between time and space.

13. **Amortized Analysis**

    * Array resizing example (dynamic arrays).

---

### **Part 4 ‚Äì Problem-Solving Patterns**

14. **Identifying Complexity from Code**

    * How to ‚Äúread‚Äù loops, recursion, and function calls.

15. **Recurrence Relations & Recursion**

    * Fibonacci example.
    * Master theorem (explained in simple words).

16. **Real-World Use Cases**

    * Why companies care in interviews.
    * Choosing the right approach in projects.

---